/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoscaleDownObservation struct {
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleDownParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationPeriods *float64 `json:"evaluationPeriods,omitempty" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	MaxScaleDownPercentage *float64 `json:"maxScaleDownPercentage,omitempty" tf:"max_scale_down_percentage,omitempty"`
}

type AutoscaleHeadroomObservation struct {
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscaleHeadroomParameters struct {

	// +kubebuilder:validation:Optional
	CPUPerUnit *float64 `json:"cpuPerUnit,omitempty" tf:"cpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	GpuPerUnit *float64 `json:"gpuPerUnit,omitempty" tf:"gpu_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryPerUnit *float64 `json:"memoryPerUnit,omitempty" tf:"memory_per_unit,omitempty"`

	// +kubebuilder:validation:Optional
	NumOfUnits *float64 `json:"numOfUnits,omitempty" tf:"num_of_units,omitempty"`
}

type AutoscalerObservation struct {
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	AutoscaleCooldown *float64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	AutoscaleDown []AutoscaleDownObservation `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	AutoscaleHeadroom []AutoscaleHeadroomObservation `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	ResourceLimits []ResourceLimitsObservation `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AutoscalerParameters struct {

	// +kubebuilder:validation:Optional
	AutoHeadroomPercentage *float64 `json:"autoHeadroomPercentage,omitempty" tf:"auto_headroom_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleCooldown *float64 `json:"autoscaleCooldown,omitempty" tf:"autoscale_cooldown,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleDown []AutoscaleDownParameters `json:"autoscaleDown,omitempty" tf:"autoscale_down,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleHeadroom []AutoscaleHeadroomParameters `json:"autoscaleHeadroom,omitempty" tf:"autoscale_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsAutoConfig *bool `json:"autoscaleIsAutoConfig,omitempty" tf:"autoscale_is_auto_config,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleIsEnabled *bool `json:"autoscaleIsEnabled,omitempty" tf:"autoscale_is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	EnableAutomaticAndManualHeadroom *bool `json:"enableAutomaticAndManualHeadroom,omitempty" tf:"enable_automatic_and_manual_headroom,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedResourceDefinitions []*string `json:"extendedResourceDefinitions,omitempty" tf:"extended_resource_definitions,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceLimits []ResourceLimitsParameters `json:"resourceLimits,omitempty" tf:"resource_limits,omitempty"`
}

type AwsObservation struct {
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	Autoscaler []AutoscalerObservation `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	BlockDeviceMappings []BlockDeviceMappingsObservation `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	ClusterOrientation []ClusterOrientationObservation `json:"clusterOrientation,omitempty" tf:"cluster_orientation,omitempty"`

	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	InstanceMetadataOptions []InstanceMetadataOptionsObservation `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	LoadBalancers []LoadBalancersObservation `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	Logging []LoggingObservation `json:"logging,omitempty" tf:"logging,omitempty"`

	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	ScheduledTask []ScheduledTaskObservation `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	SpreadNodesBy *string `json:"spreadNodesBy,omitempty" tf:"spread_nodes_by,omitempty"`

	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	Tags []TagsObservation `json:"tags,omitempty" tf:"tags,omitempty"`

	UpdatePolicy []UpdatePolicyObservation `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type AwsParameters struct {

	// +kubebuilder:validation:Optional
	AssociateIPv6Address *bool `json:"associateIpv6Address,omitempty" tf:"associate_ipv6_address,omitempty"`

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *bool `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	Autoscaler []AutoscalerParameters `json:"autoscaler,omitempty" tf:"autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	Blacklist []*string `json:"blacklist,omitempty" tf:"blacklist,omitempty"`

	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterOrientation []ClusterOrientationParameters `json:"clusterOrientation,omitempty" tf:"cluster_orientation,omitempty"`

	// +kubebuilder:validation:Optional
	ControllerID *string `json:"controllerId,omitempty" tf:"controller_id,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredCapacity *float64 `json:"desiredCapacity,omitempty" tf:"desired_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	DrainingTimeout *float64 `json:"drainingTimeout,omitempty" tf:"draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	EBSOptimized *bool `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// +kubebuilder:validation:Optional
	FallbackToOndemand *bool `json:"fallbackToOndemand,omitempty" tf:"fallback_to_ondemand,omitempty"`

	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceMetadataOptions []InstanceMetadataOptionsParameters `json:"instanceMetadataOptions,omitempty" tf:"instance_metadata_options,omitempty"`

	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancers []LoadBalancersParameters `json:"loadBalancers,omitempty" tf:"load_balancers,omitempty"`

	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	RootVolumeSize *float64 `json:"rootVolumeSize,omitempty" tf:"root_volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduledTask []ScheduledTaskParameters `json:"scheduledTask,omitempty" tf:"scheduled_task,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	SpotPercentage *float64 `json:"spotPercentage,omitempty" tf:"spot_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	SpreadNodesBy *string `json:"spreadNodesBy,omitempty" tf:"spread_nodes_by,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UpdatePolicy []UpdatePolicyParameters `json:"updatePolicy,omitempty" tf:"update_policy,omitempty"`

	// +kubebuilder:validation:Optional
	UseAsTemplateOnly *bool `json:"useAsTemplateOnly,omitempty" tf:"use_as_template_only,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeCommitments *bool `json:"utilizeCommitments,omitempty" tf:"utilize_commitments,omitempty"`

	// +kubebuilder:validation:Optional
	UtilizeReservedInstances *bool `json:"utilizeReservedInstances,omitempty" tf:"utilize_reserved_instances,omitempty"`

	// +kubebuilder:validation:Optional
	Whitelist []*string `json:"whitelist,omitempty" tf:"whitelist,omitempty"`
}

type BlockDeviceMappingsObservation struct {
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	EBS []EBSObservation `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type BlockDeviceMappingsParameters struct {

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	EBS []EBSParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`
}

type ClusterOrientationObservation struct {
	AvailabilityVsCost *string `json:"availabilityVsCost,omitempty" tf:"availability_vs_cost,omitempty"`
}

type ClusterOrientationParameters struct {

	// +kubebuilder:validation:Optional
	AvailabilityVsCost *string `json:"availabilityVsCost,omitempty" tf:"availability_vs_cost,omitempty"`
}

type DynamicVolumeSizeObservation struct {
	BaseSize *float64 `json:"baseSize,omitempty" tf:"base_size,omitempty"`

	Resource *string `json:"resource,omitempty" tf:"resource,omitempty"`

	SizePerResourceUnit *float64 `json:"sizePerResourceUnit,omitempty" tf:"size_per_resource_unit,omitempty"`
}

type DynamicVolumeSizeParameters struct {

	// +kubebuilder:validation:Required
	BaseSize *float64 `json:"baseSize" tf:"base_size,omitempty"`

	// +kubebuilder:validation:Required
	Resource *string `json:"resource" tf:"resource,omitempty"`

	// +kubebuilder:validation:Required
	SizePerResourceUnit *float64 `json:"sizePerResourceUnit" tf:"size_per_resource_unit,omitempty"`
}

type EBSObservation struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	DynamicVolumeSize []DynamicVolumeSizeObservation `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type EBSParameters struct {

	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	DynamicVolumeSize []DynamicVolumeSizeParameters `json:"dynamicVolumeSize,omitempty" tf:"dynamic_volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	Encrypted *bool `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// +kubebuilder:validation:Optional
	Iops *float64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// +kubebuilder:validation:Optional
	Throughput *float64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ExportObservation struct {
	S3 []S3Observation `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ExportParameters struct {

	// +kubebuilder:validation:Optional
	S3 []S3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type FiltersObservation struct {
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type FiltersParameters struct {

	// +kubebuilder:validation:Optional
	Architectures []*string `json:"architectures,omitempty" tf:"architectures,omitempty"`

	// +kubebuilder:validation:Optional
	Categories []*string `json:"categories,omitempty" tf:"categories,omitempty"`

	// +kubebuilder:validation:Optional
	DiskTypes []*string `json:"diskTypes,omitempty" tf:"disk_types,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeFamilies []*string `json:"excludeFamilies,omitempty" tf:"exclude_families,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeMetal *bool `json:"excludeMetal,omitempty" tf:"exclude_metal,omitempty"`

	// +kubebuilder:validation:Optional
	Hypervisor []*string `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeFamilies []*string `json:"includeFamilies,omitempty" tf:"include_families,omitempty"`

	// +kubebuilder:validation:Optional
	IsEnaSupported *string `json:"isEnaSupported,omitempty" tf:"is_ena_supported,omitempty"`

	// +kubebuilder:validation:Optional
	MaxGpu *float64 `json:"maxGpu,omitempty" tf:"max_gpu,omitempty"`

	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MaxNetworkPerformance *float64 `json:"maxNetworkPerformance,omitempty" tf:"max_network_performance,omitempty"`

	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`

	// +kubebuilder:validation:Optional
	MinEnis *float64 `json:"minEnis,omitempty" tf:"min_enis,omitempty"`

	// +kubebuilder:validation:Optional
	MinGpu *float64 `json:"minGpu,omitempty" tf:"min_gpu,omitempty"`

	// +kubebuilder:validation:Optional
	MinMemoryGib *float64 `json:"minMemoryGib,omitempty" tf:"min_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MinNetworkPerformance *float64 `json:"minNetworkPerformance,omitempty" tf:"min_network_performance,omitempty"`

	// +kubebuilder:validation:Optional
	MinVcpu *float64 `json:"minVcpu,omitempty" tf:"min_vcpu,omitempty"`

	// +kubebuilder:validation:Optional
	RootDeviceTypes []*string `json:"rootDeviceTypes,omitempty" tf:"root_device_types,omitempty"`

	// +kubebuilder:validation:Optional
	VirtualizationTypes []*string `json:"virtualizationTypes,omitempty" tf:"virtualization_types,omitempty"`
}

type InstanceMetadataOptionsObservation struct {
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`
}

type InstanceMetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *float64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// +kubebuilder:validation:Required
	HTTPTokens *string `json:"httpTokens" tf:"http_tokens,omitempty"`
}

type LoadBalancersObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoadBalancersParameters struct {

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type LoggingObservation struct {
	Export []ExportObservation `json:"export,omitempty" tf:"export,omitempty"`
}

type LoggingParameters struct {

	// +kubebuilder:validation:Optional
	Export []ExportParameters `json:"export,omitempty" tf:"export,omitempty"`
}

type ResourceLimitsObservation struct {
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type ResourceLimitsParameters struct {

	// +kubebuilder:validation:Optional
	MaxMemoryGib *float64 `json:"maxMemoryGib,omitempty" tf:"max_memory_gib,omitempty"`

	// +kubebuilder:validation:Optional
	MaxVcpu *float64 `json:"maxVcpu,omitempty" tf:"max_vcpu,omitempty"`
}

type RollConfigObservation struct {
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	BatchSizePercentage *float64 `json:"batchSizePercentage,omitempty" tf:"batch_size_percentage,omitempty"`

	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type RollConfigParameters struct {

	// +kubebuilder:validation:Optional
	BatchMinHealthyPercentage *float64 `json:"batchMinHealthyPercentage,omitempty" tf:"batch_min_healthy_percentage,omitempty"`

	// +kubebuilder:validation:Required
	BatchSizePercentage *float64 `json:"batchSizePercentage" tf:"batch_size_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchSpecIds []*string `json:"launchSpecIds,omitempty" tf:"launch_spec_ids,omitempty"`

	// +kubebuilder:validation:Optional
	RespectPdb *bool `json:"respectPdb,omitempty" tf:"respect_pdb,omitempty"`
}

type S3Observation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type S3Parameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`
}

type ScheduledTaskObservation struct {
	ShutdownHours []ShutdownHoursObservation `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	Tasks []TasksObservation `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ScheduledTaskParameters struct {

	// +kubebuilder:validation:Optional
	ShutdownHours []ShutdownHoursParameters `json:"shutdownHours,omitempty" tf:"shutdown_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Tasks []TasksParameters `json:"tasks,omitempty" tf:"tasks,omitempty"`
}

type ShutdownHoursObservation struct {
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	TimeWindows []*string `json:"timeWindows,omitempty" tf:"time_windows,omitempty"`
}

type ShutdownHoursParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TimeWindows []*string `json:"timeWindows" tf:"time_windows,omitempty"`
}

type TagsObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TasksObservation struct {
	CronExpression *string `json:"cronExpression,omitempty" tf:"cron_expression,omitempty"`

	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	TaskType *string `json:"taskType,omitempty" tf:"task_type,omitempty"`
}

type TasksParameters struct {

	// +kubebuilder:validation:Required
	CronExpression *string `json:"cronExpression" tf:"cron_expression,omitempty"`

	// +kubebuilder:validation:Required
	IsEnabled *bool `json:"isEnabled" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Required
	TaskType *string `json:"taskType" tf:"task_type,omitempty"`
}

type UpdatePolicyObservation struct {
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	RollConfig []RollConfigObservation `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	ShouldRoll *bool `json:"shouldRoll,omitempty" tf:"should_roll,omitempty"`
}

type UpdatePolicyParameters struct {

	// +kubebuilder:validation:Optional
	AutoApplyTags *bool `json:"autoApplyTags,omitempty" tf:"auto_apply_tags,omitempty"`

	// +kubebuilder:validation:Optional
	ConditionedRoll *bool `json:"conditionedRoll,omitempty" tf:"conditioned_roll,omitempty"`

	// +kubebuilder:validation:Optional
	RollConfig []RollConfigParameters `json:"rollConfig,omitempty" tf:"roll_config,omitempty"`

	// +kubebuilder:validation:Required
	ShouldRoll *bool `json:"shouldRoll" tf:"should_roll,omitempty"`
}

// AwsSpec defines the desired state of Aws
type AwsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AwsParameters `json:"forProvider"`
}

// AwsStatus defines the observed state of Aws.
type AwsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AwsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Aws is the Schema for the Awss API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,spotinst-ocean-aws}
type Aws struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.securityGroups)",message="securityGroups is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.subnetIds)",message="subnetIds is a required parameter"
	Spec   AwsSpec   `json:"spec"`
	Status AwsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AwsList contains a list of Awss
type AwsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Aws `json:"items"`
}

// Repository type metadata.
var (
	Aws_Kind             = "Aws"
	Aws_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Aws_Kind}.String()
	Aws_KindAPIVersion   = Aws_Kind + "." + CRDGroupVersion.String()
	Aws_GroupVersionKind = CRDGroupVersion.WithKind(Aws_Kind)
)

func init() {
	SchemeBuilder.Register(&Aws{}, &AwsList{})
}
